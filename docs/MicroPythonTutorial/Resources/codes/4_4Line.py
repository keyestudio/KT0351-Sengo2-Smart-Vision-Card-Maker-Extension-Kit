from machine import I2C,UART,Pinfrom  Sengo2  import *import time# Wait for Sengo2 to complete the initialization of the operating system. This waiting time cannot be removed to prevent the situation where the controller has already developed and sent instructions before Sengo2 has been fully initializedtime.sleep(3)# Choose UART or I2C communication mode. Sengo2 is I2C mode by default. You can switch between the two by short pressing the mode button.# Four UART communication modes: UART9600 (Standard Protocol Instruction), UART57600 (Standard Protocol Instruction), UART115200 (Standard Protocol Instruction), Simple9600 (Simple Protocol Instruction)########################################################################################################## port = UART(2,rx=Pin(16),tx=Pin(17),baudrate=9600)port = I2C(0,scl=Pin(21),sda=Pin(20),freq=400000)# The communication address of Sengo2 is 0x60. If multiple devices are connected to the I2C bus, please avoid address conflicts.sengo2 = Sengo2(0x60)err = sengo2.begin(port)print("sengo2.begin: 0x%x"% err)# Set the number of detection lines. The algorithm is set to 1 by default and can detect up to 5 items at mostsengo2.VisionSetMode(sengo2_vision_e.kVisionLine,4) # 1. Algorithm documentation# 2. Please keep the default settings: Only detect one line segment# 3. During normal use, the main controller sends commands to control the on and off of Sengo2 algorithm, rather than manual operation by joystick.# 4. Under specific restrictive conditions, Sengo2 can run multiple recognition algorithms in parallelerr = sengo2.VisionBegin(sengo2_vision_e.kVisionLine)print("sengo2.VisionBegin(sengo2_vision_e.kVisionLine):0x%x"% err)        while True:# Sengo2 does not actively return the detection and recognition results; it requires the main control board to send instructions for reading.# The reading process: 1.read the number of recognition results. 2.After receiving the instruction, Sengo2 will refresh the result data. 3.If the number of results is not zero, the board will then send instructions to read the relevant information. # (Please be sure to build the program according to this process.)    obj_num = sengo2.GetValue(sengo2_vision_e.kVisionLine, sentry_obj_info_e.kStatus)        if obj_num:        print(f"Totally {obj_num} lines detected")        for i in range(1,obj_num+1):           #Obtain the line angle (0-180 degrees)           angle = sengo2.GetValue(sengo2_vision_e.kVisionLine,sentry_obj_info_e.kLabel,i)           #Obtain the coordinates of the line endpoints           x1 = sengo2.GetValue(sengo2_vision_e.kVisionLine,sentry_obj_info_e.kXValue,i)           y1 = sengo2.GetValue(sengo2_vision_e.kVisionLine,sentry_obj_info_e.kYValue,i)           x2 = sengo2.GetValue(sengo2_vision_e.kVisionLine,sentry_obj_info_e.kWidthValue,i)           y2 = sengo2.GetValue(sengo2_vision_e.kVisionLine,sentry_obj_info_e.kHeightValue,i)           print("Line #%d: Start=(%d,%d), End(%d,%d), Angle=%d"%(i,x1,y1,x2,y2,angle))        time.sleep(0.2)        